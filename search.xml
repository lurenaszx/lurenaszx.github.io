<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2022/07/12/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>这是我第一篇博客</p>
]]></content>
  </entry>
  <entry>
    <title>一道图论大杂烩题的分析</title>
    <url>/2022/07/29/%E4%B8%80%E9%81%93%E5%9B%BE%E8%AE%BA%E5%A4%A7%E6%9D%82%E7%83%A9%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>今天“杭电杯”出了场图论大杂烩题–1002 Link with Running（题目链接：<a href="https://acm.hdu.edu.cn/showproblem.php?pid=7175">Problem - 7175 (hdu.edu.cn)</a>），整体上用了最短路图，targan还有最长路，都是我不太懂的知识点（貌似我好像只会最短路），所以正好就这题来给它们挨个学习加巩固一遍。</p>
<p>这道题的主要思路便是就energy求一遍最短路，并得出相应的最短路图，同时我们注意到一条边的energy可能为0，所以生成的图里是有环的可能的，所以说用targan整出个无环图，进而再用最长路来求取最大的physical fitness，从而得到两个答案。</p>
<p>1.最短路图</p>
<p>最短路相信大家都了解，最短路图实则就是所有最短路构成的图。</p>
<p>实际上我们需要做的便是对每一条边判断它是否在图中，而这个判断也很简单。事实上，先跑一遍dijkstra从而获得dis数组（表示每一个点到初始点s的最短距离），紧接着对于每一条边，设其由u到v并且边权为w，则其在图中的充要条件便是：</p>
<p>$dis[u]+w&#x3D;dis[v]$</p>
<p>必要性显然，充分性的话利用归纳搜索一次也可以显然证明。也就是说，我们这样便能找到一张图，其中不管怎么走到一个点，所走的路径都是那个点的最短路径，这便使我们可以接下来在这张图里找最大路。</p>
<blockquote>
<p>看了题目和题解的同学会发现，在原题中给定了起点和终点，所以我们只要这两点间的最短路构成的图即可，但是题解的做法实则只考虑到起点，而未将终点纳入限制。什么意思呢，就是对于点u，如果说起点s可以到达u，但是没有一条s到终点t的路径里包含u，那么在构图的时候我们实则可以忽略掉u了，而下面的解法则还是考虑了。所以如果想避免其，可以弄一个反向图，以t为起点来一个dijkstra，整出个dis2（原来的叫做dis1），那么边要满足：$dis1[u]+w+dis2[v]&#x3D;&#x3D;dis1[t]$</p>
<p>时才能纳入便可以了。（此想法源自博客<a href="https://blog.csdn.net/qq_34991215/article/details/100173588?ops_request_misc=%7B%22request_id%22:%22165900692316782390580240%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165900692316782390580240&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-100173588-null-null.142%5Ev35%5Econtrol&utm_term=%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%9B%BE&spm=1018.2226.3001.4187">(67条消息) 最短路图(dijkistra)_简单666的博客-CSDN博客_最短路图</a>）</p>
</blockquote>
<p>以下为题解中的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> pii = std::pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line">    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;dis[S]=<span class="number">0</span>,S&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u = pq.<span class="built_in">top</span>().second;</span><br><span class="line">        ll d = pq.<span class="built_in">top</span>().first;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(d!=dis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(Edge edge:e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v = edge.v;</span><br><span class="line">            <span class="type">int</span> w = edge.w1;</span><br><span class="line">            <span class="keyword">if</span>(dis[u]+w&lt;dis[v])&#123;</span><br><span class="line">                dis[v] = dis[u]+w;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n,function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; addEdge)</span></span>&#123;</span><br><span class="line">    <span class="built_in">dijkstra</span>(n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[u]==INF) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(Edge edge:e[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[u]+edge.w1==dis[edge.v])&#123;</span><br><span class="line">                <span class="built_in">addEdge</span>(u,edge.v,edge.w1,edge.w2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.targan缩点</p>
<p>targan的目的主要是找出一个图中的强连通分量，再将每一个强连通分量对应一个点构成一个新图，这样我们便能得到一个有向无环图。关于targan的原理本人道行浅薄暂时不做解释，日后可能会专门发一篇文章。</p>
<p>以下为题解中代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> GetDag&#123;</span><br><span class="line">    vector&lt;Edge&gt; e[MN+<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="type">bool</span> ins[MN+<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> low[MN+<span class="number">5</span>],dfn[MN+<span class="number">5</span>],scc[MN+<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> dfnCnt=<span class="number">0</span>,sccCnt=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            e[i].<span class="built_in">clear</span>();</span><br><span class="line">            ins[i] = <span class="literal">false</span>;</span><br><span class="line">            dfn[i] = low[i] = scc[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfnCnt = <span class="number">0</span>;</span><br><span class="line">        sccCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w1,<span class="type">int</span> w2)</span></span>&#123;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(&#123;v,w1,w2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        dfn[u] = ++dfnCnt;</span><br><span class="line">        low[u] = dfn[u];</span><br><span class="line">        s.<span class="built_in">push</span>(u);</span><br><span class="line">        ins[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(Edge edge:e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v = edge.v;</span><br><span class="line">            <span class="keyword">if</span>(dfn[v])&#123;</span><br><span class="line">                <span class="keyword">if</span>(ins[v])&#123;</span><br><span class="line">                    low[u] = <span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(v);</span><br><span class="line">                low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line">            <span class="type">int</span> v;</span><br><span class="line">            ++sccCnt;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                v = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                ins[v] = <span class="literal">false</span>;</span><br><span class="line">                scc[v] = sccCnt;</span><br><span class="line">            &#125;<span class="keyword">while</span>(u!=v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span>&amp; n,function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; addEdge,<span class="type">bool</span> isLoop[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Edge edge:e[u])&#123;</span><br><span class="line">                <span class="type">int</span> v = edge.v;</span><br><span class="line">                <span class="keyword">if</span>(scc[u]==scc[v])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(edge.w2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        isLoop[scc[u]] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">addEdge</span>(scc[u],scc[edge.v],edge.w1,edge.w2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.最大路</p>
<p>其实最大路的思想类似于求最小路，但为什么不能直接搬过来呢，因为如果说按照dijkstra的思路，每次选出一个最长的路径来，同时把此路径对应点v标记并用其更新，我们会惊奇的发现，这样是不对的，因为这或许不是v的最长路径。原因的话可以看看右边这张图：<img src="https://lurenyphoto.oss-cn-hangzhou.aliyuncs.com/img/202207282102168.jpg" alt="img" style="zoom:25%;" /></p>
<p>可以看到如果用求最小路的思路，会得到b的最长路径值为2，而实际上应该为4（换句话来讲，如果说求最短路的过程中出现了负值的边，我们会发现这个dijkstra算法也是不行的）。</p>
<p>故为了实现其，我们必须要转换往队列里加点的条件，其不再是dis受到更新，而是所有经过它的边此刻都已使用过（当所有经过它的边都考虑到了，这时它的dis必然就是最大值），当然，这个思路能行有一个条件，那便是这个图得是有向无环的，因此上一步的targan便很关键了。相关的实现可以看看题解中的代码。</p>
<blockquote>
<p>听别人说这个思路很像是拓扑，笔者太弱了不太清楚拓扑，以后可能会更新相关内容。</p>
</blockquote>
<p>附上题解中的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> GetLp&#123;</span><br><span class="line">    <span class="type">int</span> din[MN+<span class="number">5</span>];</span><br><span class="line">    <span class="type">bool</span> isLoop[MN+<span class="number">5</span>];</span><br><span class="line">    vector&lt;Edge&gt; e[MN+<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Dis</span>&#123;</span><br><span class="line">        ll d;</span><br><span class="line">        <span class="built_in">Dis</span>(ll d=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;d = d;</span><br><span class="line">        &#125;</span><br><span class="line">        Dis <span class="keyword">operator</span> + (<span class="type">const</span> Dis&amp; that)<span class="type">const</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(d==-INF||that.d==-INF) <span class="keyword">return</span> <span class="built_in">Dis</span>(-INF);</span><br><span class="line">            <span class="keyword">if</span>(d==INF||that.d==INF) <span class="keyword">return</span> <span class="built_in">Dis</span>(INF);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Dis</span>(d+that.d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Dis&amp; that)<span class="type">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;d &lt; that.d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Dis f[MN+<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            din[i] = <span class="number">0</span>;</span><br><span class="line">            isLoop[i] = <span class="literal">false</span>;</span><br><span class="line">            e[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w1,<span class="type">int</span> w2)</span></span>&#123;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(&#123;v,w1,w2&#125;);</span><br><span class="line">        din[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            f[i] = -INF;</span><br><span class="line">        &#125;</span><br><span class="line">        f[S] = <span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(din[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(isLoop[u]) f[u] = f[u] +INF;</span><br><span class="line">            <span class="keyword">for</span>(Edge edge:e[u])&#123;</span><br><span class="line">                <span class="type">int</span> v = edge.v;</span><br><span class="line">                <span class="type">int</span> w = edge.w2;</span><br><span class="line">                f[v] = <span class="built_in">max</span>(f[v],f[u]+w);</span><br><span class="line">                <span class="keyword">if</span>(--din[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
